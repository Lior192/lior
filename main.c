/*מטלת מחה (ממ"ן) 14
חומר הלימוד למטלה: פרויקט גמר
קיימת אפשרות אחת להגשת המטלה:
שליחה באמצעות מערכת המטלות המקוות באתר הבית של הקורס
הסבר מפורט ב"והל הגשת מטלות מחה"

אחת המטרות העיקריות של הקורס "20465 - מעבדה בתכות מערכות" היא לאפשר ללומדים
 המערכת השכיחות. בקורס להתסות בכתיבת פרויקט תוכה גדול, אשר יחקה את פעולתה של אחת מתוכיות
עליכם לכתוב תוכת אסמבלר, עבור שפת אסמבלי שתוגדר בהמשך. הפרויקט ייכתב בשפת C.
עליכם להגיש את הפריטים הבאים:
.1 קבצי המקור של התוכית שכתבתם (קבצים בעלי סיומת c. או h.(.
.2 קובץ הרצה (מקומפל ומקושר) עבור מערכת אובוטו.
.3 קובץ makefile. הקימפול חייב להיות עם הקומפיילר gcc והדגלים: pedantic- ansi- Wall.-
אזהרות. יש לפות את כל ההודעות שמוציא הקומפיילר, כך שהתוכית תתקמפל ללא כל הערות או
.4 דוגמאות הרצה (קלט ופלט):
אלה. יש להדגים שימוש במגוון הפעולות וטיפוסי התוים של שפת האסמבלי. א. קבצי קלט בשפת אסמבלי, וקבצי הפלט שוצרו מהפעלת האסמבלר על קבצי קלט
וצרים קבצי פלט), ותדפיסי המסך המראים את הודעות השגיאה שמוציא האסמבלר. ב. קבצי קלט בשפת אסמבלי המדגימים מגוון רחב של סוגי שגיאות אסמבלי (ולכן לא

 שקוד המקור של התוכית יעמוד בקריטריוים של בהירות, קריאות וכתיבה אה ומובית. בשל גודל הפרויקט, עליכם לחלק את התוכית למספר קבצי מקור, לפי משימות. יש להקפיד
 זכיר מספר היבטים חשובים של כתיבת קוד טוב:
.1 הפשטה של מבי התוים: רצוי (ככל האפשר) להפריד בין הגישה למבי התוים לבין
המימוש של מבי התוים. כך, למשל, בעת כתיבת פוקציות לטיפול בטבלה, אין זה
.3 תיעוד: יש להכיס בקבצי המקור תיעוד תמציתי וברור, שיסביר את תפקידה של כל הקוד באופן מסודר: הזחות עקביות, שורות ריקות להפרדה בין קטעי קוד, וכד'. .2 קריאות הקוד: יש להשתמש בשמות משמעותיים למשתים ופוקציות. יש לערוך את באמצעות רשימה מקושרת. מעיים של המשתמשים בפוקציות אלה, האם הטבלה ממומשת באמצעות מערך או
 משתים חשובים. כמו כן, יש להכיס הערות ברמת פירוט טובה בכל הקוד. פוקציה (באמצעות הערות כותרת לכל פוקציה). כמו כן יש להסביר את תפקידם של
מספר השאלות 1 משקל המטלה: 61 קודות (חובה) :
 מועד אחרון להגשה: 02.04.2025
סמסטר: 2025א'

26
הסטדרטיות, וכמובן לא בקוד ולא בחלקי קוד המצאים ברשת, במקור חיצוי וכו'. על המטלה להיות מקורית לחלוטין: אין להיעזר בספריות חיצויות מלבד הספריות כמתואר לעיל, אשר משקלם המשותף מגיע עד לכ- 40% ממשקל הפרויקט. לציון גבוה. כדי לקבל ציון גבוה, על התוכית לעמוד בקריטריוים של כתיבה ותיעוד ברמה טובה, הערה: תוכית "עובדת", דהייו תוכית שמבצעת את כל הדרוש ממה, איה לכשעצמה ערובה
לאחר מכן לקרוא שוב בצורה מעמיקה יותר. מומלץ לקרוא את הגדרת הפרויקט פעם ראשוה ברצף, לקבלת תמוה כללית לגבי הדרש, ורק קבוצת החיה. הציון יהיה זהה לשי הסטודטים. ייבדק ולא יקבל ציון. חובה שסטודטים, הבוחרים להגיש יחד את הפרויקט, יהיו שייכים לאותה מומלץ לעבוד בזוגות. אין לעבוד בצוותים גדולים יותר. פרויקט שיוגש על ידי שלשה או יותר, לא
כידוע, קיימות שפות תכות רבות, ומספר גדול של תוכיות, הכתובות בשפות שוות, עשויות לרוץ רקע כללי ומטרת הפרויקט
למעשה שפה אחת בלבד: הוראות ותוים הכתובים בקוד ביארי. קוד זה מאוחסן בגוש בזיכרון, באותו מחשב עצמו. כיצד "מכיר" המחשב כל כך הרבה שפות? התשובה פשוטה: המחשב מכיר
למעשה, זיכרון המחשב כולו הוא אוסף של סיביות, שוהגים לראותן כמקובצות ליחידות בעלות הרצף הזה לקטעים קטים בעלי משמעות: הוראות, מעים ותוים. וראה כמו רצף של ספרות ביאריות. יחידת העיבוד המרכזית - היע"מ (CPU (- יודעת לפרק את
יחידת העיבוד המרכזית (היע"מ) יכולה לבצע מגוון פעולות פשוטות, הקראות הוראות מכוה, חלק בזיכרון שבו מצאת תוכית לבין שאר הזיכרון. אורך קבוע (בתים, מילים). לא יתן להבחין, בעין שאיה מיומת, בהבדל פיסי כלשהו בין אותו
ולשם כך היא משתמשת ברגיסטרים (registers (הקיימים בתוך היע"מ, ובזיכרון המחשב.
ברגיסטר, בדיקה האם מספר המאוחסן ברגיסטר שווה לאפס, חיבור וחיסור בין שי רגיסטרים, דוגמאות: העברת מספר מתא בזיכרון לרגיסטר ביע"מ או בחזרה, הוספת 1 למספר המצא
היע"מ יודע לבצע קוד שמצא בפורמט של שפת מכוה. זהו רצף של ביטים, המהווים קידוד מיוחדת לצורה סופית זו. כל תוכית מקור (התוכית כפי שכתבה בידי המתכת), תתורגם בסופו של דבר באמצעות תוכה הוראות המכוה ושילובים שלהן הן המרכיבות תוכית כפי שהיא טעוה לזיכרון בזמן ריצתה. וכד'.
ביארי של סדרת הוראות המכוה המרכיבות את התוכית. קוד כזה איו קריא למשתמש, ולכן
 במחשב. תרגום זה עשה באמצעות כלי שקרא אסמבלר (assembler(. כמובן שיש צורך לתרגם את הייצוג הסימבולי לקוד בשפת מכוה, כדי שהתוכית תוכל לרוץ היא שפת תכות מאפשרת לייצג את הוראות המכוה בצורה סימבולית קלה ווחה יותר לשימוש. לא וח לקודד (או לקרוא) תוכיות ישירות בשפת מכוה. שפת אסמבלי (language assembly (
תפקידו של האסמבלר הוא לבות קובץ המכיל קוד מכוה, מקובץ תון של תוכית הכתובה בשפת אסמבלי ייעודית משלו. לפיכך, גם האסמבלר (כלי התרגום) הוא ייעודי ושוה לכל יע"מ. לכל מודל של יע"מ (כלומר לכל אירגון של מחשב) יש שפת מכוה ייעודית משלו, ובהתאם גם שפת מקור לשפת מכוה. האסמבלר משמש בתפקיד דומה עבור שפת אסמבלי. כידוע, לכל שפת תכות עילית יש מהדר (compiler (, או מפרש (interpreter(, המתרגם תוכיות
לעבודת שלבי הקישור והטעיה. התייחסויות אלה ועדו על מת לאפשר לכם להבין את המשך לתשומת לב: בהסברים הכלליים על אופן עבודת תוכת האסמבלר, תהיה מדי פעם התייחסות גם אסמבלי שגדיר כאן במיוחד לצורך הפרויקט. המשימה בפרויקט זה היא לכתוב אסמבלר (כלומר תוכית המתרגמת לשפת מכוה), עבור שפת המחשב. השלבים הבאים הם קישור (linkage (וטעיה (loading(, אך בהם לא עסוק בממ"ן זה. אסמבלי. זהו השלב הראשון במסלול אותו עוברת התוכית, עד לקבלת קוד המוכן לריצה על חומרת
27
תהליך העיבוד של הפלט של תוכת האסמבלר. אין לטעות: עליכם לכתוב את תוכית האסמבלר
בלבד. אין לכתוב את תוכיות הקישור והטעיה!!!
המחשב הדמיוי ושפת האסמבלי
"חומרה": הערה: תיאור מודל המחשב להלן הוא חלקי בלבד, ככל שחוץ לביצוע המשימות בפרויקט. גדיר עתה את שפת האסמבלי ואת מודל המחשב הדמיוי, עבור פרויקט זה.
המחשב בפרויקט מורכב ממעבד CPU) יע"מ - יחידת עיבוד מרכזית), רגיסטרים (אוגרים) וזיכרון
 RAM. חלק מהזיכרון משמש גם כמחסית (stack(.
והסיבית המשמעותית ביותר כמס' .23 שמות הרגיסטרים כתבים תמיד עם אות ‘r ‘קטה. גודלו של כל רגיסטר הוא 24 סיביות. הסיבית הכי פחות משמעותית תצוין כסיבית מס' ,0 למעבד 8 רגיסטרים כלליים, בשמות: 7r 6,r 5,r 4,r 3,r 2,r 1,r 0,r.

כמו כן יש במעבד רגיסטר בשם PSW) word status program(, המכיל מספר דגלים המאפייים
מחשב זה עובד רק עם מספרים שלמים חיוביים ושליליים. אין תמיכה במספרים ממשייים. קרא גם בשם "מילה". הסיביות בכל מילה ממוספרות כמו ברגיסטר. 2 – ,0 וכל תא הוא בגודל של 24 סיביות . לתא בזיכרון 21 2 תאים, בכתובות -1 21 גודל הזיכרון הוא השימוש בדגלים אלו. את מצב הפעילות במעבד בכל רגע תון. ראו בהמשך, בתיאור הוראות המכוה, הסברים לגבי
האריתמטיקה עשית בשיטת המשלים ל- 2 (complement s’2(.
כמו כן יש תמיכה בתווים (characters(, המיוצגים בקוד ascii.
כל הוראת מכוה במודל שלו מורכבת מפעולה ואופרדים. מספר האופרדים הוא בין 0 ל,2- מבה הוראת מכוה:
יעד (destination(. בהתאם לסוג הפעולה. מבחית התפקיד של כל אופרד, בחין בין אופרד מקור (source (ואופרד
כל הוראת מכוה מקודדת למספר מילות זיכרון רצופות, החל ממילה אחת ועד למקסימום שלוש
(ראו פרטים לגבי קבצי פלט בהמשך). בקובץ הפלט המכיל את קוד המכוה שבוה האסמבלר, כל מילה תקודד בבסיס הקסאדצימלי מילים, בהתאם לשיטת המיעון בה תון כל אופרד (ראו פרטים בהמשך).
מבה המילה הראשוה בהוראה הוא כדלהלן: בכל סוגי הוראות המכוה, המבה של המילה הראשוה תמיד זהה.
23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
יעד רגיסטר funct A R E מיעון
רגיסטר יעד
מקור
מיעון
opcode מקור

 ערכי שי שדות במילה הראשוה של ההוראה: קוד-הפעולה (opcode(, ופוקציה ( funct(. בשפת אסמבלי באופן סימבולי על ידי שם-פעולה, ובקוד המכוה על ידי קומביציה ייחודית של במודל המכוה שלו יש 16 פעולות, בפועל, למרות שיתן לקודד יותר פעולות. כל פעולה מיוצגת

28
 להלן טבלת הפעולות:
הפעולה שם funct) בבסיס עשרוי) קוד-הפעולה
0 mov
1 cmp
2 1 add
2 sub 2
4 lea
5 1 clr
5 2 not
5 3 inc
5 4 dec
9 1 jmp
9 2 bne
9 3 jsr
12 red
13 prn
14 rts
15 stop

 להלן מפרט השדות במילה הראשוה בקוד המכוה של כל הוראה. הערה: שם-הפעולה כתב תמיד באותיות קטות. פרטים על מהות הפעולות השוות יובאו בהמשך.
אם אין בהוראה אופרד יעד, סיביות אלה יהיו מאופסות. סיביות :12-11 מכילות את מספרה של שיטת המיעון של אופרד היעד. אחרת, סיביות אלה יהיו מאופסות סיביות :15-13 מכילות את מספרו של רגיסטר המקור, במקרה שאופרד המקור הוא רגיסטר. מפרט של שיטות המיעון השוות ייתן בהמשך. אם אין בהוראה אופרד מקור, סיביות אלה יהיו מאופסות. סיביות :17-16 מכילות את מספרה של שיטת המיעון של אופרד המקור. בלבד, הסיביות של השדה funct יהיו מאופסות. לכל פעולה מקבוצת הפעולות שיש להן אותו קוד-פעולה. אם קוד-הפעולה משמש לפעולה אחת שלה משותף לכמה פעולות שוות (כאמור, קודי-פעולה ,2 5 או 9). השדה funct יכיל ערך ייחודי סיביות :7-3 שדה זה, הקרא funct, מתפקד כאשר מדובר בפעולה שקוד-הפעולה (opcode (פעולה זהה (ראו בטבלה לעיל, קודי-פעולה ,2 5 או 9), ומה שמבדיל בייהן הוא השדה funct. סיביות :23-18 סיביות אלה מכילות את קוד-הפעולה (opcode(. ישן מספר פעולות עם קוד
 שיטות המיעון בהמשך). לתשומת לב: השדה ‘E,R,A ‘מתווסף לכל אחת מהמילים בקידוד ההוראה (ראו המפרט של במילה הראשוה של כל הוראה, ערך הסיבית A תמיד ,1 ושתי הסיביות האחרות (E,R (מאופסות. סיביות 2-0 (השדה ‘E,R,A(‘: אפיון משמעותו של שדה זה בקוד המכוה יובא בהמשך. אחרת סיביות אלה יהיו מאופסות סיביות :10-8 מכילות את מספרו של רגיסטר היעד, במקרה שאופרד היעד הוא רגיסטר.
29
 שיטות מיעון:

 בוסף למילה הראשוה. השימוש בחלק משיטות המיעון מצריך מילות-מידע וספות בקוד המכוה של הוראת המכוה, בשפת האסמבלי שלו קיימות ארבע שיטות מיעון, המסומות במספרים .0,1,2,3
 מילת-המידע של אופרד היעד. אופרדים הדורשים מילת-מידע וספת, קודם תופיע מילת-המידע של אופרד המקור, ולאחריה לכל אופרד של ההוראה דרשת לכל היותר מילת-מידע אחת וספת. כאשר בהוראה יש שי
כל מילת-מידע וספת של ההוראה מקודדת באחד משלשה סוגים של קידוד. סיביות 0-2 של כל
 פרדת, שערכה 1 אם מילת-המידע תוה בסוג קידוד זה, ואחרת ערך הסיבית הוא .0 מילת-מידע הן השדה ‘E,R,A‘, המציין מהו סוג הקידוד של המילה. לכל סוג קידוד יש סיבית
בשלבי הקישור והטעיה.  סיבית 2 (הסיבית A (מציית שקידוד המילה הוא מוחלט (Absolute (, ואיו מצריך שיוי
ומצריך שיוי בשלבי הקישור והטעיה.  סיבית 1 (הסיבית R (מציית שהקידוד הוא של כתובת פימית היתת להזזה (Relocatable(,
 בשלבי הקישור והטעיה.  סיבית 0 (הסיבית E (מציית שהקידוד הוא של כתובת חיצוית (External(, ומצריך שיוי
 ערך השדה ‘E,R,A ‘הדרש בכל אחת משיטות המיעון מופיע בתיאור שיטות המיעון להלן. הסבר על התפקיד של השדה ‘E,R,A ‘בקוד המכוה יבוא בהמשך.
מספר שיטת המיעון תוכן מילת-המידע הוספת אופן כתיבת האופרד דוגמה
בדוגמה זו האופרד 2r #-1, mov
הראשון של הפקודה
הערך -1 אל רגיסטר 2r. ההוראה כותבת את בשיטת מיעון מיידי. (אופרד המקור) תון
האופרד מתחיל בתו #
 מספר שלם בבסיס עשרוי. ולאחריו ובצמוד אליו מופיע
מילת-מידע וספת של ההוראה
מספר שלם בשיטת המשלים ל,2- מכילה את האופרד עצמו, שהוא
 בסיביות 23-3 של המילה. ברוחב של 21 סיביות, השוכן
הסיביות 2-0 של מילת המידע הן
השדה E,R,A. במיעון מיידי, ערך
האחרות מאופסות. הסיבית A הוא ,1 ושתי הסיביות
 מיעון מיידי 0
30
מספר שיטת המיעון תוכן מילת-המידע הוספת אופן כתיבת האופרד דוגמה
השורה הבאה מגדירה
 את התווית x:
x: .data 23
ההוראה:
dec x
המילה שבכתובת x מקטיה ב1- את תוכן
בזיכרון (ה"משתה" x(.

 ההוראה דוגמה וספת:
 jmp next
השורה בה מוגדרת מבצעת קפיצה אל
התווית next) כלומר
מצאת בכתובת next(. ההוראה הבאה שתתבצע
הכתובת next תקודד
המידע הוספת. בסיביות 23-3 של מילת
האופרד הוא תווית שכבר
הקובץ. ההגדרה עשית על הוגדרה, או שתוגדר בהמשך
ידי כתיבת התווית בתחילת
השורה של החית ‘data.‘או
‘string.‘, או בתחילת השורה
של הוראה, או באמצעות
סימבולי כתובת בזיכרון. התווית מייצגת באופן אופרד של החית ‘extern.‘.
23-3 של מילת המידע. ברוחב של 21 סיביות, בסיביות הכתובת מיוצגת כמספר ללא סימן בכתובת זו בזיכרון היא האופרד. מכילה כתובת בזיכרון. המילה מילת-מידע וספת של ההוראה
הסיביות 2-0 במילת המידע הן
השדה E,R,A. במיעון ישיר, ערך
הכתובת הרשומה בסיביות הסיביות האלה תלוי בסוג
.23-3 אם זוהי כתובת שמייצגת
(כתובת פימית), ערך הסיבית R שורה בקובץ המקור הוכחי
מאופסות. ואילו אם זוהי כתובת הוא ,1 ושתי הסיביות האחרות
שמייצגת שורה בקובץ מקור אחר
של התוכית (כתובת חיצוית),
הסיביות האחרות מאופסות. ערך הסיבית E הוא ,1 ושתי
 מיעון ישיר 1
 jmp &next
מבצעת קפיצה אל השורה בדוגמה זו, ההוראה
בה מוגדרת התווית next
שתתבצע מצאת בכתובת (כלומר ההוראה הבאה
שבדוגמה מצאת יח כי ההוראה jmp next(.
בכתובת 500 (עשרוי).
כמו כן, יח כי התווית
300 (עשרוי). המקור הוכחי בכתובת next מוגדרת בקובץ
מרחק הקפיצה אל
ההוראה בכתובת next
מילת המידע הוספת. יקודד בסיביות 23-3 של הוא ,-200 ומרחק זה
האופרד מתחיל בתו &
שם של תווית. ולאחריו ובצמוד אליו מופיע
התווית מייצגת באופן
התוכית. בקובץ המקור הוכחי של סימבולי כתובת של הוראה
או שתוגדר בהמשך הקובץ. ייתכן שהתווית כבר הוגדרה,
ההגדרה עשית על ידי כתיבת
לא יתן להשתמש בתווית יודגש כי בשיטת מיעון יחסי הוראה. התווית בתחילת שורת
(כתובת) שמוגדרת בקובץ
 מקור אחר (כתובת חיצוית).

שיטה זו רלווטית אך ורק
(הסתעפות) להוראה אחרת. להוראות המבצעות קפיצה
בלבד: jsr ,bne ,jmp. מדובר בקודי- הפעולה הבאים
מכתובת ההוראה הוכחית מרחק הקפיצה, במילות זיכרון, מילת מידע וספת המכילה את בשיטה זו, יש בקידוד ההוראה בהוראות עם קודי-פעולה אחרים. לא יתן להשתמש בשיטה זו
(פקודת הקפיצה) אל כתובת
מרחק הקפיצה מיוצג כמספר עם הבאה לביצוע). ההוראה המבוקשת (ההוראה
סימן בשיטת המשלים ל2- ברוחב
23-3 של מילת המידע הוספת. של 21 סיביות, השוכן בסיביות
מרחק זה יהיה שלילי במקרה
שהקפיצה היא אל הוראה
שבכתובת יותר מוכה, וחיובי
 שבכתובת יותר גבוהה. במקרה שהקפיצה היא אל הוראה
הסיביות 2-0 של מילת המידע הן
השדה E,R,A. במיעון יחסי, ערך
האחרות מאופסות. הסיבית A הוא ,1 ושתי הסיביות
 מיעון יחסי 2
31
מספר שיטת המיעון תוכן מילת-המידע הוספת אופן כתיבת האופרד דוגמה
 clr r1
בדוגמה זו, ההוראה clr
הרגיסטר 1r. מאפסת את תוכן
האופרד הוא שם של
האופרד הוא רגיסטר. רגיסטר.
לשיטת מיעון זו אין מילת מידע
רגיסטר מקור/יעד. ההוראה, בשדה המתאים: מקודד במילה הראשוה של וספת. מספרו של הרגיסטר
מיעון רגיסטר
 ישיר
 3
בתיאור הוראות המכוה שתמש במוח PC) קיצור של (“Counter Program(“. מפרט הוראות המכוה:
 מצאת ההוראה הוכחית שמתבצעת (הכווה תמיד לכתובת המילה הראשוה של ההוראה). זהו רגיסטר פימי של המעבד (לא רגיסטר כללי), שמכיל בכל רגע תון את כתובת הזיכרון בה
 הוראות המכוה מתחלקות לשלוש קבוצות, לפי מספר האופרדים הדרוש לפעולה.
 אלו הן הוראות הדורשות שי אופרדים. קבוצת ההוראות הראשוה:
ההוראות השייכות לקבוצה זו הן: lea ,sub ,add ,cmp ,mov


הוראה opcode הפעולה המתבצעת funct דוגמה הסבר הדוגמה
בזיכרון) אל רגיסטר 1r.) המילה שבכתובת A העתק את תוכן המשתה A
מבצעת העתקה של תוכן אופרד 1r ,A mov
אופרד היעד (האופרד השי). המקור (האופרד הראשון) אל
0 mov
לתוכו של רגיסטר 1r אזי אם תוכן המשתה A זהה
הדגל Z") דגל האפס")
יודלק, אחרת הדגל יאופס. ברגיסטר הסטטוס (PSW(
מבצעת השוואה בין שי 1r ,A cmp
האופרדים. ערך אופרד היעד
(השי) מופחת מערך אופרד
המקור (הראשון), ללא שמירת
תוצאת החיסור. פעולת החיסור
מעדכת דגל בשם Z") דגל
האפס") ברגיסטר הסטטוס
 .(PSW)
1 cmp
ותוכו הוכחי של 0r. החיבור של תוכן המשתה A רגיסטר 0r מקבל את תוצאת
אופרד היעד (השי) מקבל את 0r ,A add
המקור (הראשון) והיעד (השי). תוצאת החיבור של אופרד
1 2 add
רגיסטר 1r מקבל את תוצאת
הוכחי של הרגיסטר 1r. החיסור של הקבוע 3 מתוכו
אופרד היעד (השי) מקבל את 1r #3, sub
המקור (הראשון) מאופרד היעד תוצאת החיסור של אופרד
(השי) .
 2 2 sub
המען שמייצגת התווית
 HELLO מוצב לרגיסטר 1r.
lea הוא קיצור (ראשי תיבות) של 1r ,HELLO lea
זו מציבה את המען בזיכרון address effective load. פעולה
המיוצג על ידי התווית שבאופרד
היעד (האופרד השי). הראשון (המקור), אל אופרד
 4 lea


32
קבוצת ההוראות השיה:
אלו הן הוראות הדורשות אופרד אחד בלבד. אופן הקידוד של האופרד הוא כמו של אופרד היעד
 ההוראה אים בשימוש, ולפיכך יהיו מאופסים. בפקודה עם שי אופרדים. השדות של אופרד המקור (סיביות 17-13) במילה הראשוה בקידוד
clr, not, inc, dec, jmp, bne, jsr, red, prn :הן זו לקבוצה השייכות ההוראות
הוראה opcode הפעולה המתבצעת funct דוגמה הסבר הדוגמה
הרגיסטר 2r מקבל את הערך
 .0
clr 1 5 איפוס תוכן האופרד 2r clr
ולהיפך: 1 ל0-). סיבית שערכה 0 תהפוך ל1- היפוך ערכי הסיביות באופרד (כל 2r not כל ביט ברגיסטר 2r מתהפך.
 5 2 not
תוכן הרגיסטר 2r מוגדל ב-
 .1
inc 3 5 הגדלת תוכן האופרד באחד. 2r inc
מוקטן ב- .1 תוכן המשתה Count
dec 4 5 הקטת תוכן האופרד באחד. Count dec
PCPC+distanceTo(Line)
מצביע התכית מקבל את
המען שמחושב על ידי חיבור
ההוראה הוכחית, ולפיכך המרחק לתווית Line עם מען
תהיה במען Line. ההוראה הבאה שתתבצע
קפיצה (הסתעפות) בלתי מותית Line &jmp
כתוצאה מביצוע ההוראה, מצביע המיוצג על ידי האופרד. כלומר, אל ההוראה שמצאת במען
יעד הקפיצה. התוכית (PC (מקבל את כתובת
 9 1 jmp
אם ערך הדגל Z ברגיסטר
הסטטוס (PSW (הוא ,0 אזי
PC  address(Line)
מצביע התכית יקבל את
כתובת התווית Line, ולפיכך
תהיה במען Line. ההוראה הבאה שתתבצע
bne Line :של) תיבות ראשי (קיצור הוא bne .branch if not equal (to zero)
זוהי הוראת הסתעפות מותית.
אם ערכו של הדגל Z ברגיסטר
מצביע התוכית (PC (מקבל את הסטטוס (PSW (היו ,0 אזי
Z קבע באמצעות הוראת cmp. כתובת יעד הקפיצה. כזכור, הדגל
 9 2 bne
push(PC+2)
PC  address(SUBR)
כתובת התווית SUBR, מצביע התכית יקבל את
שמרת במחסית. כתובת החזרה מהשגרה שתתבצע תהיה במען SUBR. ולפיכך, ההוראה הבאה
כתובת ההוראה שאחרי הוראת קריאה לשגרה (סברוטיה). SUBR jsr
דחפת (PC+2 ) וכחיתה jsr
לתוך המחסית שבזיכרון
הערה: חזרה מהשגרה מתבצעת מקבל את כתובת השגרה. המחשב, ומצביע התוכית (PC(
בכתובת שבמחסית. באמצעות הוראת rts, תוך שימוש
 9 3 jsr
קוד ה-ascii של התו הקרא
מהקלט ייכס לרגיסטר 1r.
קריאה של תו מהקלט הסטדרטי 1r red
(stdin (אל האופרד.
 12 red
יודפס לפלט התו (קוד ascii(
המצא ברגיסטר 1r
הדפסת התו המצא באופרד, אל 1r prn
הפלט הסטדרטי (stdout(.
 13 prn

33
 ולפיכך יהיו מאופסים. המקור ושל אופרד היעד (סיביות 17-8) במילה הראשוה של קידוד ההוראה אים בשימוש, אלו הן הוראות ללא אופרדים. קידוד ההוראה מורכב ממילה אחת בלבד. השדות של אופרד קבוצת ההוראות השלישית:
 ההוראות השייכות לקבוצה זו הן: stop ,rts.
הוראה הפעולה המתבצעת opcode דוגמה הסבר הדוגמה
 PC  pop()
ההוראה הבאה שתתבצע
שקראה לשגרה. תהיה זו שאחרי הוראת jsr
מתבצעת חזרה משיגרה. rts
ומוכס למצביע התוכית (PC(. המחשב מוצא מן המחסית, הערך שבראש המחסית של
הערה: ערך זה כס למחסית
בקריאה לשגרה ע"י הוראת jsr
14 rts
stop 15 עצירת ריצת התוכית. stop התוכית עוצרת מיידית.

 מבה שפת האסמבלי:
מאקרואים: תכית בשפת אסמבלי בויה ממאקרואים וממשפטים (statements(.
 mc_a mcro הגדרת מאקרו עשית באופן הבא: (בדוגמה שם המאקרו הוא mc_a (לאותו מקום. במקומות שוים בתוכית. השימוש במאקרו ממקום מסוים בתוכית יגרום לפרישת המאקרו מאקרואים הם קטעי קוד הכוללים בתוכם משפטים. בתוכית יתן להגדיר מאקרו ולהשתמש בו
 inc r2
 mov A,r1
mcroend
 . למשל, אם בתוכית במקום כלשהו כתוב: שימוש במאקרו הוא פשוט אזכור שמו.
.
a_mc
.
.
a_mc
.
.
בדוגמה זו, השתמשו פעמיים במאקרו mc_a, התוכית לאחר פרישת המאקרו תיראה כך:
.
.
 inc r2
 mov A,r1
.
.
 inc r2
 mov A,r1
.
.
34
 התוכית לאחר פרישת המאקרו היא התוכית שהאסמבלר אמור לתרגם.
החות והחיות לגבי מאקרו:
 אין במערכת הגדרות מאקרו מקוות (אין צורך לבדוק זאת).
 שם של הוראה או החיה לא יכול להיות שם של מאקרו (יש לבדוק זאת).
צורך לבדוק זאת).  יתן להיח שלכל שורת מאקרו בקוד המקור קיימת סגירה עם שורת mcroend) אין
 הגדרת מאקרו תהיה תמיד לפי הקריאה למאקרו (אין צורך לבדוק זאת).
(הרחבה של קובץ המקור המתואר בהמשך). "קובץ המקור המורחב" הוא "קובץ  דרש שהקדם-אסמבלר ייצור קובץ עם הקוד המורחב הכולל פרישה של המאקרו
לסיכום, במאקרו יש לבדוק: למערכת, כולל הגדרת המאקרואים. מקור" לאחר פרישת המאקרו, לעומת "קובץ מקור ראשוי" שהוא קובץ הקלט
 (1) שם המאקרו תקין (איו שם הוראה וכדומה)
 (2) בשורת ההגדרה ובשורת הסיום אין תווים וספים
אם מצאה שגיאה בשלב פרישת המאקרו - אי אפשר לעבור לשלבים הבאים:
יש לעצור להודיע על השגיאות ולעבור לקובץ המקור הבא (אם קיים).
קובץ מקור בשפת אסמבלי מורכב משורות המכילות משפטים של השפה, כאשר כל משפט מופיע משפטים: הערה: שגיאות בגוף המאקרו (אם יש) מגלים בשלבים הבאים.
בשורה פרדת. כלומר, ההפרדה בין משפט למשפט בקובץ המקור היה באמצעות התו ‘n) ‘\שורה
יש ארבעה סוגי משפטים (שורות בקובץ המקור) בשפת אסמבלי, והם: אורכה של שורה בקובץ המקור הוא 80 תווים לכל היותר (לא כולל התו n(\. חדשה).

סוג המשפט הסבר כללי
זוהי שורה המכילה אך ורק תווים לבים (whitespace(, כלומר רק את
n(\, כלומר השורה ריקה. התווים ‘ ’ ו- ‘t) ‘\רווחים וטאבים). ייתכן ובשורה אין אף תו (למעט התו
משפט ריק
להתעלם לחלוטין משורה זו. זוהי שורה בה התו הראשון היו ‘;’ (קודה פסיק). על האסמבלר
משפט הערה
זהו משפט המחה את האסמבלר מה עליו לעשות כשהוא פועל על תכית
המקור. יש מספר סוגים של משפטי החיה. משפט החיה עשוי לגרום
קידוד של הוראות מכוה המיועדות לביצוע בעת ריצת התכית. להקצאת זיכרון ואתחול משתים של התכית, אך הוא איו מייצר
משפט החיה
זהו משפט המייצר קידוד של הוראות מכוה לביצוע בעת ריצת התכית.
של ההוראה. המשפט מורכב משם של הוראה שעל המעבד לבצע, ותיאור האופרדים
משפט הוראה
 משפט החיה הוא בעל המבה הבא: משפט החיה: כעת פרט יותר לגבי סוגי המשפטים השוים.
שם של החיה מתחיל בתו ‘.’ (קודה) ולאחריו תווים באותיות קטות (case lower (בלבד. לאחר מכן מופיע שם ההחיה. לאחר שם ההחיה יופיעו פרמטרים (מספר הפרמטרים בהתאם להחיה). בהמשך. התווית היא אופציולית. בתחילת המשפט יכולה להופיע הגדרה של תווית (label(. לתווית יש תחביר חוקי, שיתואר

35
יש לשים לב: למילים בקוד המכוה הוצרות ממשפט החיה לא מצורף השדה E,R,A, והקידוד
 ממלא את כל הסיביות של המילה.


יש ארבעה סוגים של משפטי החיה, והם:

.1 ההחיה ‘data. ‘

התו ‘,’ (פסיק). לדוגמה: הפרמטרים של ההחיה ‘data. ‘הם מספרים שלמים חוקיים (אחד או יותר) המופרדים על ידי

יש לשים לב שהפסיקים אים חייבים להיות צמודים למספרים. בין מספר לפסיק ובין פסיק 9 +17, −57, 7, data.
למספר יכולים להופיע רווחים וטאבים בכל כמות (או בכלל לא), אולם הפסיק חייב להופיע בין
 האחרון או לפי המספר הראשון. המספרים. כמו כן, אסור שיופיע יותר מפסיק אחד בין שי מספרים, וגם לא פסיק אחרי המספר
המשפט ‘data. ‘מחה את האסמבלר להקצות מקום בתמות התוים (image data(, אשר בו
יאוחסו הערכים של הפרמטרים, ולקדם את מוה התוים, בהתאם למספר הערכים. אם
בהחית data. מוגדרת תווית, אזי תווית זו מקבלת את ערך מוה התוים (לפי הקידום),
שם התווית (למעשה, זוהי דרך להגדיר שם של משתה) . ומוכסת אל טבלת הסמלים. דבר זה מאפשר להתייחס אל מקום מסוים בתמות התוים דרך
כלומר אם כתוב:

XYZ: .data 7, –57, +17, 9
אם כתוב בתכית את ההוראה: התווית XYZ מזוהה עם כתובת המילה הראשוה. אזי יוקצו בתמות התוים ארבע מילים רצופות שיכילו את המספרים שמופיעים בהחיה.

mov XYZ, r1
אזי בזמן ריצת התכית יוכס לרגיסטר 1r הערך .7
ואילו ההוראה:
lea XYZ, r1
תכיס לרגיסטר 1r את ערך התווית XYZ) כלומר הכתובת בזיכרון בה מאוחסן הערך 7).

.2 ההחיה ‘string. ‘

להחיה ‘string. ‘פרמטר אחד, שהוא מחרוזת חוקית. תווי המחרוזת מקודדים לפי ערכי ה-ascii
המתאימים, ומוכסים אל תמות התוים לפי סדרם, כל תו במילה פרדת. בסוף המחרוזת
יתווסף התן ‘0\’ (הערך המספרי 0), המסמן את סוף המחרוזת. מוה התוים של האסמבלר
יקודם בהתאם לאורך המחרוזת (בתוספת מקום אחד עבור התו המסיים). אם בשורת ההחיה
מוגדרת תווית, אזי תווית זו מקבלת את ערך מוה התוים (לפי הקידום) ומוכסת אל טבלת
לדוגמה, ההחיה: מתחילה המחרוזת). הסמלים, בדומה למה שעשה עבור ‘data.) ‘כלומר ערך התווית יהיה הכתובת בזיכרון שבה
36
STR: .string "abcdef"
מקצה בתמות התוים רצף של 7 מילים, ומאתחלת את המילים לקודי ה-ascii של התווים לפי
 התחלת המחרוזת. הסדר במחרוזת, ולאחריהם הערך 0 לסימון סוף מחרוזת. התווית STR מזוהה עם כתובת
 .3 ההחיה 'entry. '
להחיה 'entry. 'פרמטר והוא שם של תווית המוגדרת בקובץ המקור הוכחי (כלומר תווית
לקוד אסמבלי המצא בקבצי מקור אחרים להשתמש בה (כאופרד של הוראה). שמקבלת את ערכה בקובץ זה). מטרת ההחיה entry. היא לאפיין את התווית הזו באופן שיאפשר


HELLO entry. לדוגמה, השורות:
HELLO: add #1, r1
..……

 מודיעות לאסמבלר שאפשר להתייחס בקובץ אחר לתווית HELLO המוגדרת בקובץ הוכחי.
 מתווית זו (אפשר שהאסמבלר יוציא הודעת אזהרה). לתשומת לב: תווית המוגדרת בתחילת שורת entry. היה חסרת משמעות והאסמבלר מתעלם

.4 ההחיה 'extern.'
להחיה 'extern. 'פרמטר והוא שם של תווית שאיה מוגדרת בקובץ המקור הוכחי. מטרת
שים לב כי החיה זו תואמת להחית 'entry. 'המופיעה בקובץ בו מוגדרת התווית. בשלב הקישור הוכחי עושה בתווית שימוש. ההוראה היא להודיע לאסמבלר כי התווית מוגדרת בקובץ מקור אחר, וכי קוד האסמבלי בקובץ
קידוד ההוראות המשתמשות בתווית בקבצים אחרים (שלב הקישור איו רלווטי לממ"ן זה). תתבצע התאמה בין ערך התווית, כפי שקבע בקוד המכוה של הקובץ שהגדיר את התווית, לבין

 לדוגמה, משפט ההחיה 'extern. 'התואם למשפט ההחיה 'entry 'מהדוגמה הקודמת יהיה:
 לעיל, התווית HELLO(. הערה: לא יתן להגדיר באותו הקובץ את אותה התווית גם כ-entry וגם כ-extern) בדוגמאות HELLO extern.
.3 אופרדים, בהתאם לסוג הפעולה (בין 0 ל- 2 אופרדים). .2 שם הפעולה. .1 תווית אופציולית. משפט הוראה מורכב מהחלקים הבאים: משפט הוראה: מתווית זו (אפשר שהאסמבלר יוציא הודעת אזהרה). לתשומת לב: תווית המוגדרת בתחילת שורת extern. היה חסרת משמעות והאסמבלר מתעלם
 המילה הראשוה של ההוראה בתוך תמות הקוד שבוה האסמבלר. אם מוגדרת תווית בשורת ההוראה, אזי היא תוכס אל טבלת הסמלים. ערך התווית יהיה מען
37
שם הפעולה תמיד באותיות קטות (case lower(, והוא אחת מ- 16 הפעולות שפורטו לעיל.
למשפט הוראה עם שי אופרדים המבה הבא: הפסיק היא חוקית. לא חייבת להיות הצמדה של האופרדים לפסיק. כל כמות של רווחים ו/או טאבים משי צידי כאשר יש שי אופרדים, האופרדים מופרדים זה מזה בתו ‘,’ (פסיק). בדומה להחיה ‘data.‘, האופרד הראשון באמצעות רווחים ו/או טאבים (אחד או יותר). לאחר שם הפעולה יופיעו האופרדים, בהתאם לסוג הפעולה. יש להפריד בין שם-הפעולה לבין
 label: opcode source-operand, target-operand :לדוגמה
 HELLO: add r7, B

למשפט הוראה עם אופרד אחד המבה הבא:
label: opcode target-operand :לדוגמה
למשפט הוראה ללא אופרדים המבה הבא: XYZ &bne :HELLO
 label: opcode :לדוגמה
 END: stop

תווית היא למעשה סמל שמוגדר בתחילת משפט הוראה, או בתחילת החיית data. או string. כאן את ההסבר: בתיאור שיטות המיעון למעלה הסברו כי תווית היא ייצוג סימבולי של כתובת בזיכרון. רחיב תווית: אפיון השדות במשפטים של שפת האסמבלי
אלפביתיות (גדולות או קטות) ו/או ספרות. האורך המקסימלי של תווית הוא 31 תווים. תווית חוקית מתחילה באות אלפביתית (גדולה או קטה), ולאחריה סדרה כלשהי של אותיות
הגדרה של תווית מסתיימת בתו ‘:’ (קודתיים). תו זה איו מהווה חלק מהתווית, אלא רק סימן
המציין את סוף ההגדרה. התו ‘:’ חייב להיות צמוד לתווית (ללא רווחים).
לדוגמה, התוויות המוגדרות להלן הן תוויות חוקיות. חשבות שוות זו מזו. אסור שאותה תווית תוגדר יותר מפעם אחת (כמובן בשורות שוות). אותיות קטות וגדולות
hEllo:
x:
He78902:
לתשומת לב: מילים שמורות של שפת האסמבלי (כלומר שם של פעולה או החיה, או שם של
 כשם של מאקרו ( יש לבדוק זאת ). רגיסטר) אין יכולות לשמש גם כשם של תווית. כמו כן, אסור שאותו סמל ישמש הן כתווית והן
38
התווית מקבלת את ערכה בהתאם להקשר בו היא מוגדרת. תווית המוגדרת בהחיות data,.
string,. תקבל את ערך מוה התוים (counter data (הוכחי, בעוד שתווית המוגדרת בשורת
 הוכחי, כל עוד הסמל מאופיין כחיצוי (באמצעות החיית extern. כלשהי בקובץ הוכחי). לתשומת לב: מותר במשפט הוראה להשתמש באופרד שהוא סמל שאיו מוגדר כתווית בקובץ הוראה תקבל את ערך מוה ההוראות (counter instruction (הוכחי.
 מספר:
מספר חוקי מתחיל בסימן אופציולי: ’–’ או ‘+’ ולאחריו סדרה כלשהי של ספרות בבסיס עשרוי.
 מחרוזת: אחר מאשר עשרוי, ואין תמיכה במספרים שאים שלמים. לדוגמה: ,76 5–, +123 הם מספרים חוקיים. אין תמיכה בשפת האסמבלי שלו בייצוג בבסיס
מחרוזת חוקית היא סדרת תווי ascii ראים (שיתים להדפסה), המוקפים במרכאות כפולות
(המרכאות אין חשבות חלק מהמחרוזת). דוגמה למחרוזת חוקית: “world hello“.
והטעיה. זה השדה E,R,A. המידע ישמש לתיקוים בקוד בכל פעם שייטען לזיכרון לצורך הרצה. בכל מילה בקוד המכוה של הוראה (לא של תוים) , האסמבלר מכיס מידע עבור תהליך הקישור סימון המילים בקוד המכוה באמצעות המאפיין “E,R,A “
המשמעות של כל ערך מפורטת להלן. שלוש הסיביות בשדה E,R,A יכילו ערכים ביאריים כפי שהוסבר בתיאור שיטות המיעון. לטעון את הקוד בכל פעם למקום אחר, בלי צורך לחזור על תהליך האסמבלי. האסמבלר בוה מלכתחילה קוד שמיועד לטעיה החל מכתובת ההתחלה. התיקוים יאפשרו
 בפועל קוד המכוה של התכית בעת ביצועה (למשל מילה המכילה אופרד מיידי). האות ‘A) ‘קיצור של absolute (באה לציין שתוכן המילה איו תלוי במקום בזיכרון בו ייטען
 המכוה של התכית בעת ביצועה (למשל מילה המכילה כתובת של תווית המוגדרת בקובץ המקור). האות ‘R) ‘קיצור של relocatable (באה לציין שתוכן המילה תלוי במקום בזיכרון בו ייטען בפועל קוד
(למשל מילה המכילה כתובת של תווית חיצוית, כלומר תווית שאיה מוגדרת בקובץ המקור). האות ‘E) ‘קיצור של external (באה לציין שתוכן המילה תלוי בערכו של סמל חיצוי (external (
כאשר האסמבלר מקבל כקלט תוכית בשפת אסמבלי, עליו לטפל תחילה בפרישת המאקרואים,
ורק לאחר מכן לעבור על התוכית אליה פרשו המאקרואים. כלומר, פרישת המאקרואים תעשה
אם התכית איה מכילה מאקרו, תוכית הפרישה תהיה זהה לתכית המקור. בשלב "קדם אסמבלר", לפי שלב האסמבלר (המתואר בהמשך) .

 דוגמה לשלב קדם אסמבלר. האסמבלר מקבל את התוכית הבאה בשפת אסמבלי:
39
MAIN: add r3, LIST
LOOP: prn #48
mcro a_mc
cmp K, #-6
 bne &END
mcroend
 lea STR, r6
 inc r6
 mov r3, K
 sub r1, r4
 bne END
a_mc
 dec K
 jmp &LOOP
END: stop
STR: .string “abcd”
LIST: .data 6, -9
 .data -100
K: .data 31

 התוכית לאחר פרישת המאקרו תיראה כך: בהצלחה, יתן לעבור לשלב הבא. אחרת, יש להציג את השגיאות ולא לייצר קבצים. בדוגמה זו, תחילה האסמבלר עובר על התוכית ופורש את כל המאקרואים הקיימים בה. רק אם תהליך זה מסתיים

MAIN: add r3, LIST
LOOP: prn #48
 lea STR, r6
 inc r6
 mov r3, K
 sub r1, r4
 bne END
 cmp K, #-6
 bne &END
 dec K
 jmp &LOOP
END: stop
STR: .string “abcd”
LIST: .data 6, -9
 .data -100
K: .data 31


קוד התכית, לאחר הפרישה, ישמר בקובץ חדש, כפי שיוסבר בהמשך.



40

 באלגוריתם זה: ציג להלן אלגוריתם שלדי לתהליך קדם האסמבלר. לתשומת לב: אין חובה להשתמש דווקא אלגוריתם שלדי של קדם האסמבלר

.1 קרא את השורה הבאה מקובץ המקור. אם גמר הקובץ, עבור ל- 9 (סיום).
.3 האם השדה הראשון הוא " mcro) " התחלת הגדרת מאקרו)? אם לא, עבור ל- .6 המשך. שם המאקרו והעתק במקומו את כל השורות המתאימות מהטבלה לקובץ, חזור ל .1 אחרת, .2 האם השדה הראשון הוא שם מאקרו המופיע בטבלת המאקרו (כגון mc_a ?(אם כן, החלף את
.5 (קיימת הגדרת מאקרו) הכס לטבלת שורות מאקרו את שם המאקרו (לדוגמה mc_a( . .4 הדלק דגל "יש mcro" .
.9 סיום: שמירת קובץ מאקרו פרוש. .8 כבה דגל "יש mcro" . חזור ל- .1 (סיום שמירת הגדרת מאקרו). .7 האם זוהתה תווית mcroend ?אם כן, מחק את התווית מהקובץ והמשך. אם לא, חזור ל- .6 ומחק את השורה ה"ל מהקובץ. אחרת (לא מאקרו) חזור ל .1 אם דגל "יש mcro " דולק ולא זוהתה תווית mcroend הכס את השורה לטבלת המאקרו .6 קרא את השורה הבאה מקובץ המקור. אם גמר קובץ המקור, עבור ל- 9 (סיום).


קודי-הפעולה ומספרי הרגיסטרים, בוים את קוד המכוה. סמל ערך מספרי שהוא המען בזיכרון שהסמל מייצג. במעבר השי, באמצעות ערכי הסמלים, וכן במעבר הראשון של האסמבלר, יש לזהות את הסמלים (תוויות) המופיעים בתוכית, ולתת לכל אסמבלר עם שי מעברים
 עליו להחליף את שמות הפעולות בקוד הביארי השקול להם במודל המחשב שהגדרו.
בזיכרון שם מצאים כל תון או הוראה בהתאמה. כמו כן, על האסמבלר להחליף את כל הסמלים (למשל MAIN ,LIST ( במעים של המקומות
 קבל את ה"תרגום" הבא: יח שקטע הקוד לעיל (הוראות ותוים) ייטען בזיכרון החל ממען 100 (בבסיס 10) . במקרה זה
41

Address
(decimal)
 Source Code Binary Machine Code Explanation
0000100
0000101
MAIN: add r3, LIST First word of instruction
Address of label LIST
000010110110100000001100
000000000000001111111010
0000102
0000103
LOOP: prn #48 Immediate value 48
001101000000000000000100
000000000000000110000100
0000104
0000105
lea STR, r6
Address of label STR
000100010001111000000100
000000000000001111010010
0000106 inc r6 000101000001111000011100
0000107
0000108
mov r3, K
Address of label K
000000110110100000000100
000000000000010000010010
0000109 sub r1, r4 000010110011110000010100
0000110
0000111
bne END
Address of label END
001001000000100000010100
000000000000001111001010
0000112
0000113
0000114
cmp K, #-6
Address of label K
Immediate value -6
000001010000000000000100
000000000000010000010010
111111111111111111010100
0000115
0000116
bne &END Distance to label END
001001000001000000010100
000000000000000000110100
0000117
0000118
dec K Address of label K
000101000000100000100100
000000000000010000010010
0000119
0000120
jmp &LOOP
Distance to label LOOP
001001000001000000001100
111111111111111101111100
0000121 END: stop 001111000000000000000100
0000122 STR: .string “abcd” Ascii code ‘a’ 000000000000000001100001
0000123 Ascii code ‘b’ 000000000000000001100010
0000124 Ascii code ‘c’ 000000000000000001100011
000 5 Ascii code ‘ 012 d’ 000000000000000001100100
0000126 Ascii code ‘\0’ 000000000000000000000000
0000127
0000128
LIST: .data 6, -9 Integer 6
Integer -9
000000000000000000000110
111111111111111111110111
000 9 012 .data -100 Integer -100 111111111111111110011100
000 30 01 K: .data 31 Integer 31 000000000000000000011111



כדי לבצע המרה לביארי של אופרדים שכתובים בשיטות מיעון המשתמשות בסמלים (תוויות), יש אפשר פשוט לעיין בטבלה ולמצוא את הקוד הביארי. המתאימים להם, ולכן שמות הפעולות יתים להמרה לביארי בקלות. כאשר קרא שם פעולה, האסמבלר מחזיק טבלה שבה רשומים כל שמות הפעולה של ההוראות והקודים הביאריים
צורך לבות טבלה המכילה את ערכי כל הסמלים. אולם בהבדל מהקודים של הפעולות, הידועים
 המקור סרקה כולה ותגלו כל הגדרות הסמלים. מראש, הרי המעים בזיכרון עבור הסמלים שבשימוש התוכית אים ידועים, עד אשר תוכית
K משויך למען ,130 אלא רק לאחר שקראו כל שורות התכית. למשל, בקוד לעיל, האסמבלר איו יכול לדעת שהסמל END משויך למען 121 (עשרוי), ושהסמל
הסמלים, עם הערכים המספריים המשויכים להם, ובשלב השי מחליפים את כל הסמלים, לכן מפרידים את הטיפול של האסמבלר בסמלים לשי שלבים. בשלב הראשון בוים טבלה של כל
 שהוא מען בזיכרון. בדוגמה לעיל, טבלת הסמלים לאחר מעבר ראשון היא: במעבר הראשון בית טבלת סמלים בזיכרון, ובה לכל סמל שבתוכית המקור משויך ערך מספרי, כרוך בשתי סריקות (הקראות "מעברים") של קובץ המקור. המופיעים באופרדים של הוראות התוכית, בערכיהם המספריים. הביצוע של שי שלבים אלה
42
ערך (בבסיס עשרוי) סמל
MAIN 100
LOOP 102
END 121
STR 122
LIST 127
K 130
של הסמלים להיות כבר ידועים. במעבר השי עשית ההמרה של קוד המקור לקוד מכוה. בתחילת המעבר השי צריכים הערכים
לתשומת לב: תפקיד האסמבלר, על שי המעברים שלו, לתרגם קובץ מקור לקוד בשפת מכוה.
במעבר הראשון דרשים כללים כדי לקבוע איזה מען ישויך לכל סמל. העיקרון הבסיסי הוא המעבר הראשון לעבור לשלבי הקישור/טעיה, ורק לאחר מכן לשלב הביצוע (שלבים אלה אים חלק מהממ"ן). בגמר פעולת האסמבלר, התכית טרם מוכה לטעיה לזיכרון לצורך ביצוע. קוד המכוה חייב
לספור את המקומות בזיכרון, אותם תופסות ההוראות. אם כל הוראה תיטען בזיכרון למקום
העוקב להוראה הקודמת, תציין ספירה כזאת את מען ההוראה הבאה. הספירה עשית על ידי
האסמבלר ומוחזקת במוה ההוראות (IC (. ערכו ההתחלתי של IC הוא 100 (עשרוי), ולכן קוד
המכוה של ההוראה הראשוה בה כך שייטען לזיכרון החל ממען .100 ה-IC מתעדכן בכל שורת
התאים (מילים) התפסים על ידי ההוראה, וכך הוא מצביע על התא הפוי הבא. הוראה המקצה מקום בזיכרון. לאחר שהאסמבלר קובע מהו אורך ההוראה, ה-IC מוגדל במספר
כאמור, כדי לקודד את ההוראות בשפת מכוה, מחזיק האסמבלר טבלה, שיש בה קוד מתאים
לכל שם פעולה. בזמן התרגום מחליף האסמבלר כל שם פעולה בקוד שלה, וכן כל אופרד מוחלף
בקידוד מתאים, אך פעולת החלפה זו איה כה פשוטה. ההוראות משתמשות בשיטות מיעון
מגווות לאופרדים. אותה פעולה יכולה לקבל משמעויות שוות, בכל אחת משיטות המיעון, ולכן
יתאימו לה קידודים שוים לפי שיטות המיעון. לדוגמה, פעולת ההזזה mov יכולה להתייחס
להעתקת תוכן תא זיכרון לרגיסטר, או להעתקת תוכן רגיסטר לרגיסטר אחר, וכן הלאה. לכל
כל השדות ביחד דורשים מילה אחת או יותר בקוד המכוה. כלל מתחלק הקידוד לשדה של שם הפעולה, ושדות וספים המכילים מידע לגבי שיטות המיעון. על האסמבלר לסרוק את שורת ההוראה בשלמותה, ולהחליט לגבי הקידוד לפי האופרדים. בדרך אפשרות כזאת של mov עשוי להתאים קידוד שוה.
כאשר תקל האסמבלר בתווית המופיעה בתחילת השורה, הוא יודע שלפיו הגדרה של תווית, ואז
הוא משייך לה מען – תוכו הוכחי של ה-IC. כך מקבלות כל התוויות את מעיהן בעת ההגדרה.
תוויות אלה מוכסות לטבלת הסמלים, המכילה בוסף לשם התווית גם את המען ומאפייים
 המען המתאים מטבלת הסמלים. וספים. כאשר תהיה התייחסות לתווית באופרד של הוראה כלשהי, יוכל האסמבלר לשלוף את
להלן לדוגמה, הוראת הסתעפות למען שמוגדר על ידי התווית A שמופיעה רק בהמשך הקוד: הוראה יכולה להתייחס גם לסמל שטרם הוגדר עד כה בתכית, אלא יוגדר רק בהמשך התכית.
 bne A
 .
 .
 .
A: ……
43
כאשר מגיע האסמבלר לשורת ההסתעפות (A bne(, הוא טרם תקל בהגדרת התווית A וכמובן
האופרד A. ראה בהמשך כיצד פתרת בעיה זו. לא יודע את המען המשויך לתווית. לכן האסמבלר לא יכול לבות את הקידוד הביארי של
של כל הוראה, את הקידוד הביארי של מילת-המידע הוספת של אופרד מיידי, או רגיסטר, וכן בכל מקרה, תמיד אפשר לבות במעבר הראשון את הקידוד הביארי המלא של המילה הראשוה
את הקידוד הביארי של כל התוים (המתקבלים מההחיות data,. string.(.
המעבר השי
ראיו שבמעבר הראשון, האסמבלר איו יכול לבות את קוד המכוה של אופרדים המשתמשים
כבר לטבלת הסמלים, יכול האסמבלר להשלים את קוד המכוה של כל האופרדים. בסמלים שעדיין לא הוגדרו. רק לאחר שהאסמבלר עבר על כל התכית, כך שכל הסמלים כסו
בסוף המעבר השי, תהיה התוכית מתורגמת בשלמותה לקוד מכוה. האופרדים המשתמשים בסמלים, באמצעות ערכי הסמלים מטבלת הסמלים. לשם כך מבצע האסמבלר מעבר וסף (מעבר שי) על כל קובץ המקור, ומעדכן את קוד המכוה של
בתכית מבחיים בשי סוגים של תוכן: הוראות ותוים. יש לארגן את קוד המכוה כך שתהיה הפרדת הוראות ותוים
עדיפה על פי הצמדה של הגדרות התוים להוראות המשתמשות בהן. הפרדה בין התוים וההוראות. הפרדת ההוראות והתוים לקטעים שוים בזיכרון היא שיטה
אחת הסכות הטמוות באי הפרדת ההוראות מהתוים היא, שלפעמים עלול המעבד, בעקבות
שגיאה לוגית בתכית, לסות "לבצע" את התוים כאילו היו הוראות חוקיות. למשל, שגיאה
כלומר בקובץ הפלט (בקוד המכוה) תהיה הפרדה של הוראות ותוים לשי קטעים פרדים, האסמבלר שלו חייב להפריד, בקוד המכוה שהוא מיצר, בין קטע התוים לקטע ההוראות. יותר חמור, כי וצרת חריגת חומרה ברגע שהמעבד מבצע פעולה שאיה חוקית. שיכולה לגרום תופעה כזו הסתעפות לא כוה. התכית כמובן לא תעבוד כון, אך לרוב הזק הוא
 פרטים כיצד לבצע את ההפרדה. ואילו בקובץ הקלט אין חובה שתהיה הפרדה כזו. בהמשך מתואר אלגוריתם של האסמבלר, ובו
החת המטלה היא שאין שגיאות בהגדרות המאקרו, ולכן שלב קדם האסמבלר איו מכיל שלב גילוי שגיאות בתכית המקור
גילוי שגיאות. אין גם צורך לבדוק שגיאות בפתיחת / סגירת המאקרו (למשל אם המאקרו לא
מסתיים – יתן להיח שה"ל תקין). לעומת זאת, האסמבלר אמור לגלות ולדווח על שגיאות
בתחביר של תוכית המקור, כגון פעולה שאיה קיימת, מספר אופרדים שגוי, סוג אופרד שאיו
הערה: אם יש שגיאה בקוד האסמבלי בגוף מאקרו, הרי שגיאה זו יכולה להופיע ולהתגלות שוב הודעת שגיאה בוסח "יותר מדי אופרדים". לדוגמה, אם מופיעים שי אופרדים בהוראה שאמור להיות בה רק אופרד יחיד, האסמבלר ייתן מכאן, שכל שגיאה המתגלה על ידי האסמבלר גרמת (בדרך כלל) על ידי שורת קלט מסוימת. מוגדר פעם אחת בדיוק. מתאים לפעולה, שם רגיסטר לא קיים, ועוד שגיאות אחרות. כמו כן מוודא האסמבלר שכל סמל
גם את מספר השורה בקובץ המקור בה זוהתה השגיאה (מיין השורות בקובץ מתחיל ב1-). האסמבלר ידפיס את הודעות השגיאה אל הפלט הסטדרטי stdout. בכל הודעת שגיאה יש לציין לזהות שזה קוד שפרש ממאקרו, כך שלא יתן לחסוך גילויי שגיאה כפולים. ושוב, בכל מקום בו פרש המאקרו. שים לב שכאשר האסמבלר בודק שגיאות, כבר לא יתן

44
לתשומת לב: האסמבלר איו עוצר את פעולתו אחרי שמצאה השגיאה הראשוה, אלא ממשיך
ההוראות השוות הקיימות בשפה התוה: הטבלה הבאה מפרטת מהן של שיטות המיעון החוקיות, עבור אופרד המקור ואופרד היעד של הפלט אם תגלו שגיאות (ממילא אי אפשר להשלים את קוד המכוה). לעבור על הקלט כדי לגלות שגיאות וספות, ככל שישן. כמובן שאין כל טעם לייצר את קבצי

עבור אופרד המקור שיטות מיעון חוקיות עבור אופרד היעד שיטות מיעון חוקיות
 Opcode שם ההוראה funct
 1,3 0,1,3 mov 0
 0,1,3 0,1,3 cmp 1
 1,3 ad 0,1,3 1 d 2
 1,3 0,1,3 2 sub 2
 1,3 le 1 4 a
5 clr 1 אין אופרד מקור 1,3
5 not 2 אין אופרד מקור 1,3
5 inc 3 אין אופרד מקור 1,3
5 dec 4 אין אופרד מקור 1,3
9 jmp 1 אין אופרד מקור 1,2
9 bne 2 אין אופרד מקור 1,2
 9 jsr 3 אין אופרד מקור 1,2
red 12 אין אופרד מקור 1,3
prn 13 אין אופרד מקור 0,1,3
rts 14 אין אופרד מקור אין אופרד יעד
stop 15 אין אופרד מקור אין אופרד יעד


 ולמעבר השי. לתשומת לב: אין חובה להשתמש דווקא באלגוריתם זה. לחידוד ההבה של תהליך העבודה של האסמבלר, ציג להלן אלגוריתם שלדי למעבר הראשון אלגוריתם שלדי של האסמבלר
או מחלקים את קוד המכוה לשי אזורים, אזור ההוראות (code (ואזור התוים (data(. לכל
אזור יש מוה משלו, וסמם IC) מוה ההוראות - Counter-Instruction (ו-DC) מוה התוים -
 Counter-Data(. בה את קוד המכוה כך שיתאים לטעיה לזיכרון החל מכתובת .100
בכל מעבר מתחילים לקרוא את קובץ המקור מהתחלה.

מעבר ראשון
.3 האם השדה הראשון בשורה הוא סמל? אם לא, עבור ל.5- .2 קרא את השורה הבאה מקובץ המקור. אם גמר קובץ המקור, עבור ל.17- .1 אתחל 100  IC 0,  DC.
.4 הדלק דגל "יש הגדרת סמל".
.8 .5 האם זוהי החיה לאחסון תוים, כלומר, האם החית data. או string. ?אם לא, עבור ל-
.6 אם יש הגדרת סמל (תווית), הכס אותו לטבלת הסמלים עם המאפיין data. ערכו יהיה
לאורכם. חזור ל.2- .7 זהה את סוג התוים, קודד אותם בזיכרון, ועדכן את מוה התוים DC בהתאם DC.) אם הסמל כבר מצא בטבלה יש להודיע על שגיאה).
.8 האם זו החית extern. או החית entry. ? אם לא, עבור ל.11-
45
.9 אם זוהי החית entry. חזור ל2- (ההחיה תטופל במעבר השי).
.10 אם זו החית extern,. הכס את הסמל המופיע כאופרד של ההחיה לתוך טבלת הסמלים עם
הערך ,0 ועם המאפיין external. חזור ל.2-
.11 זוהי שורת הוראה. אם יש הגדרת סמל, הכס אותו לטבלת הסמלים עם המאפיין code. ערכו
.12 חפש את שם הפעולה בטבלת שמות הפעולות, ואם לא מצא, אז הודע על שגיאה בשם ההוראה. של הסמל יהיה IC) אם הסמל כבר מצא בטבלה יש להודיע על שגיאה).
ההוראה בקוד המכוה (קרא למספר זה L(. .13 תח את מבה האופרדים של ההוראה, וחשב מהו מספר המילים הכולל שתופסת
המקודדת אופרד במיעון מיידי. .14 בה כעת את הקוד הביארי של המילה הראשוה של ההוראה, ושל כל מילת-מידע וספת
.15 שמור את הערכים IC ו- L יחד עם תוי קוד המכוה של ההוראה.
.17 קובץ המקור קרא בשלמותו. אם מצאו שגיאות במעבר הראשון, עצור כאן. .16 עדכן L + IC  IC, וחזור ל.2-
לביית קבצי הפלט, אחרי המעבר השי. .18 שמור את הערכים הסופיים של IC ושל DC) קרא להם ICF ו- DCF(. שתמש בהם
.19 עדכן בטבלת הסמלים את ערכו של כל סמל המאופיין כ- data , ע"י הוספת הערך ICF
.20 התחל מעבר שי. (ראה הסבר לכך בהמשך).
.2 אם השדה הראשון בשורה הוא סמל (תווית), דלג עליו. .1 קרא את השורה הבאה מקובץ המקור. אם גמר קובץ המקור, עבור ל- .7 מעבר שי
.3 האם זוהי החית data. או string. או extern. ? אם כן, חזור ל- .1
.5 הוסף בטבלת הסמלים את המאפיין entry למאפייי הסמל המופיע כאופרד של ההחיה .4 האם זוהי החית entry. ? אם לא, עבור ל- .6
.6 השלם את הקידוד הביארי של מילות-המידע של האופרדים, בהתאם לשיטות המיעון (אם הסמל לא מצא בטבלת הסמלים, יש להודיע על שגיאה). חזור ל- .1
כתובת מילת- המידע הרלווטית לרשימת מילות-מידע שמתייחסות לסמל חיצוי. לפי הצורך, (אם הסמל לא מצא בטבלה, יש להודיע על שגיאה). אם הסמל מאופיין external, הוסף את שבשימוש. לכל אופרד בקוד המקור המכיל סמל, מצא את ערכו של הסמל בטבלת הסמלים
.7 קובץ המקור קרא בשלמותו. אם מצאו שגיאות במעבר השי, עצור כאן. הראשון. חזור ל- .1 לחישוב הקידוד והכתובות, אפשר להיעזר בערכים IC ו-L של ההוראה, כפי ששמרו במעבר
.8 בה את קבצי הפלט (פרטים וספים בהמשך).

את הקוד הביארי שמתקבל במעבר ראשון ובמעבר שי. להלן שוב תכית הדוגמה: פעיל אלגוריתם זה על תוכית הדוגמה שראיו למעלה (לאחר שלב פרישת המאקרואים), וציג

MAIN: add r3, LIST
LOOP: prn #48
 lea STR, r6
 inc r6
 mov r3,K
 sub r1, r4
 bne END
 cmp K, #-6
 bne &END
 dec K
 jmp &LOOP
END: stop
STR: .string “abcd”
LIST: .data 6, -9
 .data -100
K: .data 31
46

בצע עתה מעבר ראשון על הקוד התון. בה את טבלת הסמלים. כמו כן, בצע במעבר זה גם את
קידוד כל התוים, וקידוד המילה הראשוה של כל הוראה. כמו כן, קודד מילות-מידע וספות
במעבר זה, שאיר כמות שהם (מסומים ב- ? בדוגמה להלן). של כל הוראה, ככל שקידוד זה איו תלוי בערך של סמל. את החלקים שעדיין לא מתורגמים






Address
(decimal)
 Source Code Binary Machine Code Explanation
0000100
0000101
MAIN: add r3, LIST First word of instruction
Address of label LIST
000010110110100000001100
?
0000102
0000103
LOOP: prn #48 Immediate value 48
001101000000000000000100
000000000000000110000100
0000104
0000105
lea STR, r6
Address of label STR
000100010001111000000100
?
0000106 inc r6 000101000001111000011100
0000107
0000108
mov r3, K
Address of label K
000000110110100000000100
?
0000109 sub r1, r4 000010110011110000010100
0000110
0000111
bne END
Address of label END
001001000000100000010100
?
0000112
0000113
0000114
cmp K, #-6
Address of label K
Immediate value -6
000001010000000000000100
?
111111111111111111010100
0000115
0000116
bne &END Distance to label END
001001000001000000010100
?
0000117
0000118
dec K Address of label K
000101000000100000100100
?
0000119
0000120
jmp &LOOP Distance to label LOOP
001001000001000000001100
?
0000121 END: stop 001111000000000000000100
0000122 STR: .string “abcd” Ascii code ‘a’ 000000000000000001100001
0000123 Ascii code ‘b’ 000000000000000001100010
0000124 Ascii code ‘c’ 000000000000000001100011
000 5 Ascii code ‘ 012 d’ 000000000000000001100100
0000126 Ascii code ‘\0’ 000000000000000000000000
0000127
0000128
LIST: .data 6, -9 Integer 6
Integer -9
000000000000000000000110
111111111111111111110111
000 9 012 .data -100 Integer -100 111111111111111110011100
000 30 01 K: .data 31 Integer 31 000000000000000000011111












47
טבלת הסמלים אחרי המעבר ראשון היא:

איפיון הסמל ערך (בבסיס עשרוי) סמל
MAIN 100 code
LOOP 102 code
END 121 code
STR 122 data
LIST 127 data
K 130 data



 הקוד הביארי בצורתו הסופית כאן זהה לקוד שהוצג בתחילת הושא "אסמבלר עם שי מעברים". בצע עתה את המעבר השי. שלים באמצעות טבלת הסמלים את הקידוד החסר במילים המסומות "?".
הערה: כאמור, האסמבלר בוה קוד מכוה כך שיתאים לטעיה לזיכרון החל מכתובת 100 (עשרוי).
 בשלב הטעיה, שיוכסו בעזרת מידע וסף שהאסמבלר מכין בקבצי הפלט (ראו בהמשך). אם הטעיה בפועל (לצורך הרצת התוכית) תהיה לכתובת אחרת, יידרשו תיקוים בקוד הביארי

Address
(decimal)
 Source Code Binary Machine Code Explanation
0000100
0000101
MAIN: add r3, LIST First word of instruction
Address of label LIST
000010110110100000001100
000000000000001111111010
0000102
0000103
LOOP: prn #48
Immediate value 48
001101000000000000000100
000000000000000110000100
0000104
0000105
lea STR, r6
Address of label STR
000100010001111000000100
000000000000001111010010
0000106 inc r6 000101000001111000011100
0000107
0000108
mov r3, K
Address of label K
000000110110100000000100
000000000000010000010010
0000109 sub r1, r4 000010110011110000010100
0000110
0000111
bne END
Address of label END
001001000000100000010100
000000000000001111001010
0000112
0000113
0000114
cmp K, #-6
Address of label K
Immediate value -6
000001010000000000000100
000000000000010000010010
111111111111111111010100
0000115
0000116
bne &END Distance to label END
001001000001000000010100
000000000000000000110100
0000117
0000118
dec K Address of label K
000101000000100000100100
000000000000010000010010
0000119
0000120
jmp &LOOP
Distance to label LOOP
001001000001000000001100
111111111111111101111100
0000121 END: stop 001111000000000000000100
0000122 STR: .string “abcd” Ascii code ‘a’ 000000000000000001100001
0000123 Ascii code ‘b’ 000000000000000001100010
0000124 Ascii code ‘c’ 000000000000000001100011
000 5 Ascii code ‘ 012 d’ 000000000000000001100100
0000126 Ascii code ‘\0’ 000000000000000000000000
0000127
0000128
LIST: .data 6, -9 Integer 6
Integer -9
000000000000000000000110
111111111111111111110111
000 9 012 .data -100 Integer -100 111111111111111110011100
000 30 01 K: .data 31 Integer 31 000000000000000000011111



48
בהפעלה של האסמבלר, יש להעביר אליו באמצעות ארגומטים של שורת הפקודה קבצי קלט ופלט של האסמבלר כאמור, שלבי הקישור והטעיה אים למימוש בפרויקט זה, ולא דון בהם כאן. שמכילים את הקוד הביארי ומידע וסף עבור שלבי הקישור והטעיה. בסוף המעבר השי, אם לא תגלו שגיאות, האסמבלר בוה את קבצי הפלט (ראו בהמשך),
אלו הם קבצי טקסט, ובהם תוכיות בתחביר של שפת האסמבלי שהוגדרה בממ"ן זה. (arguments line command (רשימה של שמות קבצי מקור (אחד או יותר).
 האסמבלר פועל על כל קובץ מקור בפרד, ויוצר עבורו קבצי פלט כדלקמן:
 קובץ am, המכיל את קובץ המקור לאחר שלב קדם האסמבלר (לאחר פרישת המאקרואים)
 קובץ object, המכיל את קוד המכוה.
בטבלת הסמלים כ- external(. שמקודדת ערך של סמל שהוצהר כחיצוי (סמל שהופיע כאופרד של החיית extern,. ומאופיין  קובץ externals, ובו פרטים על כל המקומות (הכתובות) בקוד המכוה בהם יש מילת-מידע
אם אין בקובץ המקור אף החיית entry,. האסמבלר לא יוצר את קובץ הפלט מסוג entries. אם אין בקובץ המקור אף החיית extern,. האסמבלר לא יוצר את קובץ הפלט מסוג externals. החיית entry,. ומאופיין בטבלת הסמלים כ- entry(.  קובץ entries, ובו פרטים על כל סמל שמוצהר כקודת כיסה (סמל שהופיע כאופרד של
 שמות חוקיים. העברת שמות הקבצים הללו כארגומטים לאסמבלר עשית ללא ציון הסיומת. שמות קבצי המקור חייבים להיות עם הסיומת “as.“. למשל, השמות as.x , as.y, ו- as.hello הם
לדוגמה: יח שתוכית האסמבלר שלו קראת assembler, אזי שורת הפקודה הבאה:
assembler x y hello
שמות קבצי הפלט מבוססים על שם קובץ הקלט, כפי שהופיע בשורת הפקודה, בתוספת סיומת תריץ את האסמבלר על הקבצים: as.hello ,as.y ,as.x.
מתאימה: הסיומת “am. “עבור קובץ לאחר פרישת מאקרו, הסיומת “ob. “עבור קובץ ה-object,
הסיומת “ent. “עבור קובץ ה-entries, והסיומת “ext. “עבור קובץ ה-externals.

לדוגמה, בהפעלת האסמבלר באמצעות שורת הפקודה: x assembler
ייווצר קובץ פלט ob.x, וכן קבצי פלט ext.x ו- ent.x ככל שיש החיות entry. או extern. בקובץ המקור.
אם אין מאקרו בקובץ המקור, אזי קובץ “am. “יהיה זהה לקובץ “as. “.

האסמבלר מחזיק שי מערכים, שייקראו להלן מערך ההוראות ומערך התוים. מערכים אלו רחיב כאן על אופן פעולת האסמבלר, בוסף לאלגוריתם השלדי שיתן לעיל. אופן פעולת האסמבלר
ותים למעשה תמוה של זיכרון המכוה (גודל כל כיסה במערך זהה לגודלה של מילת מכוה
(בסיביות). במערך ההוראות מכיס האסמבלר את הקידוד של הוראות המכוה שקראו במהלך
המעבר על קובץ המקור. במערך התוים מכיס האסמבלר את קידוד התוים שקראו מקובץ
 המקור (שורות מסוג data. string.(.
לאסמבלר יש שי מוים: מוה ההוראות (IC (ומוה התוים (DC(. מוים אלו מצביעים על
מוים אלו מקבלים ערך התחלתי. המקום הבא הפוי במערכים לעיל, בהתאמה. כשמתחיל האסמבלר לעבור על קובץ מקור, שי
49
הקובץ. לטבלה זו קוראים טבלת סמלים (table-symbol(. לכל סמל (תווית) שמרים שמו, ערכו, בוסף יש לאסמבלר טבלה, אשר בה אספות כל התוויות בהן תקל האסמבלר במהלך המעבר על
.1 שורה ריקה או שורת הערה: האסמבלר מתעלם מהשורה ועובר לשורה הבאה. החיה, או שורה ריקה) ופועל בהתאם. האסמבלר קורא את קובץ המקור שורה אחר שורה, מחליט מהו סוג השורה (הערה, הוראה, ומאפייים שוים שצויו קודם, כגון המיקום (data או code(, או אופן העדכון (למשל external(.
.2 שורת הוראה:
אם האסמבלר מוצא בשורת ההוראה גם הגדרה של תווית, אזי התווית מוכסת אל טבלת הוא מחפש קבע בהתאם להוראה אותה הוא מצא). האסמבלר מוצא מהי הפעולה, ומהן שיטות המיעון של האופרדים. (מספר האופרדים אותם
 הסמלים. ערך התווית הוא IC, והמאפיין הוא code.
האסמבלר קובע לכל אופרד את ערכו באופן הבא:
 אם זה רגיסטר – האופרד הוא מספר הרגיסטר.
והסמל טרם מצא בטבלת הסמלים).  אם זו תווית (מיעון ישיר) – האופרד הוא ערך התווית כפי שמופיע בטבלת הסמלים (ייתכן
 אם זה התו # ואחריו מספר– האופרד הוא המספר עצמו.
תיאור שיטות המיעון לעיל)  אם זו שיטת מיעון אחרת – ערכו של האופרד קבע לפי המפרט של שיטת המיעון (ראו
המיעון. למשל, מספר מציין מיעון מיידי, תווית מציית מיעון ישיר וכד'. קביעת שיטת המיעון עשית בהתאם לתחביר של האופרד, כפי שהוסבר לעיל בהגדרת שיטות
ושיטת מיעון אופרד היעד (אם יש), הוא פועל באופן הבא: לאחר שהאסמבלר יתח את השורה והחליט לגבי הפעולה, שיטת מיעון אופרד המקור (אם יש),
אם זוהי פעולה בעלת שי אופרדים, אזי האסמבלר מכיס למערך ההוראות, במקום עליו מצביע
מוה ההוראות IC, את קוד המילה הראשוה של ההוראה (בשיטת הייצוג של הוראות המכוה
כפי שתואר קודם לכן). מילה זו מכילה את קוד הפעולה, ואת שיטות המיעון. בוסף "משריין"
האסמבלר מקום במערך עבור המילים הוספות הדרשות עבור הוראה זו, ומגדיל את מוה
שאין רלווטיות לפעולה. פרט לסיביות של שיטת המיעון של אופרד המקור במילה הראשוה, אשר יכילו תמיד ,0 מכיוון אם זוהי פעולה בעלת אופרד אחד בלבד, כלומר אין אופרד מקור, אזי הקידוד היו זהה לעיל, מקודד כעת את המילים הוספות הרלווטיות במערך ההוראות. ההוראות בהתאם. אם אחד או שי האופרדים הם בשיטת מיעון רגיסטר או מיידי, האסמבלר
ערך התווית הוא ערך מוה ההוראות לפי קידוד ההוראה. אם בשורת ההוראה קיימת תווית, אזי התווית מוכסת אל טבלת הסמלים תחת השם המתאים, המיעון של האופרדים יכילו .0 אם זוהי פעולה ללא אופרדים אזי תקודד רק המילה הראשוה (והיחידה). הסיביות של שיטות
.3 שורת החיה:
 כאשר האסמבלר קורא בקובץ המקור שורת החיה, הוא פועל בהתאם לסוג ההחיה, באופן הבא:
50
 ‘.data’ .I
 התוים, ומקדם את מצביע התוים DC באחד עבור כל מספר שהוכס. האסמבלר קורא את רשימת המספרים, המופיעה לאחר ‘data.‘, מכיס כל מספר אל מערך
אם בשורה ‘data. ‘יש תווית, אזי תווית זו מוכסת לטבלת הסמלים. היא מקבלת את הערך של
 התוים. מוה התוים DC שלפי הכסת המספרים למערך התוים. כן מסומן שההגדרה יתה בחלק
 ‘.string’ .II
הטיפול ב-‘string. ‘דומה ל- ‘data.‘, אלא שקודי ה-ascii של התווים הם אלו המוכסים אל
 התוים. מוה התוים מקודם באורך המחרוזת + 1 (גם האפס בסוף המחרוזת תופס מקום). מערך התוים (כל תו בכיסה פרדת). לאחר מכן מוכס הערך 0 (המציין סוף מחרוזת) אל מערך
הטיפול בתווית המוגדרת בשורה זו זהה לטיפול העשה בהחיה ‘data.‘.

 ‘.entry’ .III
זוהי בקשה לאסמבלר להכיס את התווית המופיעה כאופרד של ‘entry. ‘אל קובץ ה-entries.
 האסמבלר רושם את הבקשה ובסיום העבודה, התווית ה"ל תירשם בקובץ ה-entries.
‘.extern’ .IV
שימוש. האסמבלר מכיס את הסמל אל טבלת הסמלים. ערכו הוא 0 (הערך האמיתי לא ידוע, זוהי הצהרה על סמל (תווית) המוגדר בקובץ אחר, ואשר קטע האסמבלי בקובץ הוכחי עושה בו
(וגם אין זה משה עבור האסמבלר). וייקבע רק בשלב הקישור), וטיפוסו הוא external. לא ידוע באיזה קובץ מצאת הגדרת הסמל
יש לשים לב: בהוראה או בהחיה אפשר להשתמש בשם של סמל אשר ההצהרה עליו יתת
בסוף המעבר הראשון, האסמבלר מעדכן בטבלת הסמלים כל סמל המאופיין כ- data, על ידי בהמשך הקובץ (אם באופן ישיר על ידי הגדרת תווית, ואם באופן עקיף על ידי החית extern(.
הוספת +100IC) עשרוי) לערכו של הסמל. הסיבה לכך היא שבתמוה הכוללת של קוד המכוה,
התוים מופרדים מההוראות, וכל התוים דרשים להופיע אחרי כל ההוראות. סמל מסוג data
 שטרם קודדו במעבר הראשון. אלו הן מילים שצריכות להכיל כתובות של תוויות. במעבר השי, האסמבלר מקודד באמצעות טבלת הסמלים את כל המילים במערך ההוראות חיצויים). טבלת הסמלים מכילה כעת את כל הערכים החוצים להשלמת הקידוד (למעט ערכים של סמלים האורך הכולל של קידוד כל ההוראות, בתוספת כתובת התחלת הטעיה של הקוד, שהיא .100 הוא למעשה תווית באזור התוים, והעדכון מוסיף לערך הסמל (כלומר לכתובתו בזיכרון) את
51

פורמט קובץ ה- object
 ואחריה ובצמוד תמות התוים. קובץ זה מכיל את תמות הזיכרון של קוד המכוה, בשי חלקים: תמות ההוראות ראשוה,
כזכור, האסמבלר מקודד את ההוראות כך שתמות ההוראות תתאים לטעיה החל מכתובת 100
ההוראות. מכיוון שתמות התוים מצאת אחרי תמות ההוראות, גודל תמות ההוראות משפיע (עשרוי) בזיכרון. שים לב שרק בסוף המעבר הראשון יודעים מהו הגודל הכולל של תמות
על הכתובות בתמות התוים. זו הסיבה שבגללה היה צורך לעדכן בטבלת הסמלים, בסוף המעבר
הראשון, את ערכי הסמלים המאופייים כ-data) כזכור, בצעד 19 הוספו לכל סמל כזה את הערך
 הסמלים, המותאמים למבה המלא והסופי של תמות הזיכרון. ICF(. במעבר השי, בהשלמת הקידוד של מילות-המידע, משתמשים בערכים המעודכים של
 כעת האסמבלר יכול לכתוב את תמות הזיכרון בשלמותה לתוך קובץ פלט (קובץ ה- object(.
השורה הראשוה בקובץ ה- object היא "כותרת", המכילה שי מספרים (בבסיס עשרוי):
תמות התוים (במילות זיכרון). בין שי המספרים מפריד רווח אחד. הראשון הוא האורך הכולל של תמות ההוראות (במילות זיכרון), והשי הוא האורך הכולל של
כזכור, במעבר הראשון, בצעד ,18 שמרו הערכים ICF ו- IDF. האורך הכולל של תמות ההוראות
 הוא −100ICF, והאורך הכולל של תמות התוים הוא IDF.
השורות הבאות בקובץ מכילות את תמות הזיכרון. בכל שורה שי שדות: כתובת של מילה
בזיכרון, ותוכן המילה. הכתובת תירשם בבסיס עשרוי בשבע ספרות (כולל אפסים מובילים).
 בשורה יש רווח אחד. תוכן המילה יירשם בבסיס הקסאדצימלי ב6- ספרות (כולל אפסים מובילים). בין שי השדות


 פורמט קובץ ה-entries
כפי שמצא בטבלת הסמלים. הערכים מיוצגים בבסיס עשרוי. קובץ ה-entries בוי משורות טקסט. כל שורה מכילה שם של סמל שהוגדר כ- entry ואת ערכו,


פורמט קובץ ה- externals
קובץ ה-externals בוי אף הוא משורות טקסט. כל שורה מכילה שם של סמל שהוגדר external,
וכתובת בקוד המכוה בה יש קידוד של אופרד המתייחס לסמל זה. כמובן שייתכן ויש מספר
 חיצוי. לכל כתובת כזו תהיה שורה פרדת בקובץ ה-externals. לתשומת לב: ייתכן ויש מספר כתובות בקוד המכוה בהן מילות-המידע מתייחסות לאותו סמל בקובץ ה-externals. הכתובות מיוצגות בבסיס עשרוי. כתובות בקוד המכוה בהם מתייחסים לאותו סמל חיצוי. לכל התייחסות כזו תהיה שורה פרדת
 התוכית לאחר שלב פרישת המאקרו תיראה כך: דגים את קבצי הפלט שמייצר האסמבלר עבור קובץ מקור בשם as.ps.









52
; file ps.as
.entry LIST
.extern W
MAIN: add r3, LIST
LOOP: prn #48
 lea W, r6
 inc r6
 mov r3, K
 sub r1, r4
 bne END
 cmp K, #-6
 bne &END
 dec W
.entry MAIN
 jmp &LOOP
 add L3, L3
END: stop
STR: .string “abcd”
LIST: .data 6, -9
 .data -100
K: .data 31
.extern L3

53
 להלן טבלת הקידוד הביארי המלא שמתקבל מקובץ המקור, כפי שבה במעבר הראשון והשי.


Address
(decimal)
 Source Code Binary Machine Code Explanation
0000100
0000101
MAIN: add r3, LIST First word of instruction
Address of label LIST
000010110110100000001100
000000000000010000010010
0000102
0000103
LOOP: prn #48
 Immediate value 48
001101000000000000000100
000000000000000110000100
0000104
0000105
lea W, r6
Address of extern label W
000100010001111000000100
0000000000000 0000000001 0
0000106 inc r6 000101000001111000011100
0000107
0000108
mov r3, K
Address of label K
000000110110100000000100
000000000000010000 010 101
0000109 sub r1, r4 000010110011110000010100
0000110
0000111
bne END
Address of label END
001001000000100000010100
000000000000001111100010
0000112
0000113
0000114
cmp K, #-6
Address of label K
Immediate value -6
000001010000000000000100
000000000000010000 010 101
111111111111111111010100
0000115
0000116
bne &END Distance to label END
001001000001000000010100
000000000000000001001100
0000117
0000118
dec W Address of extern label W
000101000000100000100100
0000000000000 0000000001 0
0000119
0000120
jmp &LOOP Distance to label LOOP
001001000001000000001100
111111111111111101111100
0000121
0000122
0000123
add L3, L3
Address of extern label L3
Address of extern label L3
000010010000100000001100
000000000000000000000001
000000000000000000000001
0000124 END: stop 001111000000000000000100
0000125 STR: .string “abcd” Ascii code ‘a’ 000000000000000001100001
0000126 Ascii code ‘b’ 000000000000000001100010
0000127 Ascii code ‘c’ 000000000000000001100011
0000128 Ascii code ‘d’ 000000000000000001100100
0000129 Ascii code ‘\0’ 000000000000000000000000
0000130
0000131
LIST: .data 6, -9 Integer 6
Integer -9
000000000000000000000110
111111111111111111110111
000 32 01 .data -100 Integer -100 111111111111111110011100
000 33 01 K: .data 31 Integer 31 000000000000000000011111

טבלת הסמלים הסופית בגמר המעבר השי היא:

איפיון הסמל ערך (בבסיס עשרוי) סמל
W 0 external
MAIN 100 code, entry
LOOP 102 code
END 124 code
STR 125 data
LIST 130 data, entry
K 133 data
L3 0 external

54
 להלן תוכן קבצי הפלט של הדוגמה.
:ps.ob הקובץ

 25 9
0000100
0000101
0000102
0000103
0000104
0000105
0000106
0000107
0000108
0000109
0000110
0000111
0000112
0000113
0000114
0000115
0000116
0000117
0000118
0000119
0000120
0000121
0000122
0000123
0000124
0000125
0000126
0000127
0000128
0000129
0000130
0000131
0000132
0000133
0b680c
000412
340004
000184
111e04
000001
141e1c
036804
00042a
0b3c14
240814
0003e2
050004
00042a
ffffd4
241014
00004c
140824
000001
24100c
ffff7c
09080c
000001
000001
3C0004
000061
000062
000063
000064
000000
000006
fffff7
ffff9c
00001f

 :ps.ent הקובץ :ps.ext הקובץ
MAIN 0000100 W 0000105
LIST 0000130 W 0000118
 L3 0000122
 L3 0000123

55

לתשומת לב: אם בקובץ המקור אין החיות extern. אזי לא ייווצר קובץ ext. בדומה, אם אין
בקובץ המקור החיות entry,. לא ייווצר קובץ ent. אין ליצור קובץ ext או ent ששאר ריק.
הערה: אין חשיבות לסדר השורות בקבצים מסוג ent. או ext. כל שורה עומדת בפני עצמה.

 סיכום והחיות כלליות

מבה תוים אחר (למשל טבלת הסמלים וטבלת המאקרו), יש לממש באופן יעיל וחסכוי מקסימלי. לפיכך יש אפשרות להשתמש במערכים לאכסון תמות קוד המכוה בלבד. כל איו אמור להיות צפוי מראש. אולם כדי להקל במימוש האסמבלר, יתן להיח גודל  אורך התוכית, היתת כקלט לאסמבלר איו ידוע מראש, ולכן אורך התוכית המתורגמת
 (למשל באמצעות רשימה מקושרת והקצאת זיכרון דיאמי).
 אם קובץ הקלט הוא as.prog אזי קבצי הפלט שיווצרו הם: ent.prog ,ext.prog ,ob.prog  השמות של קבצי הפלט צריכים להיות תואמים לשם קובץ הקלט, למעט הסיומות. למשל,
כלומר, ממשק המשתמש יהיה אך ורק באמצעות שורת הפקודה. בפרט, שמות קבצי  מתכות הפעלת האסמבלר צריכה להיות כפי הדרש בממ"ן, ללא שיויים כלשהם.
 קלט איטראקטיביים, חלוות גרפיים למייהם, וכד'. המקור יועברו לתכית האסמבלר כארגומטים בשורת הפקודה. אין להוסיף תפריטי
לרכז משימות מסוגים שוים במודול יחיד. מומלץ לחלק למודולים כגון: מעבר ראשון, מעבר  יש להקפיד לחלק את מימוש האסמבלר למספר מודולים (קבצים בשפת C (לפי משימות. אין
שי, פוקציות עזר (למשל, תרגום לבסיס, יתוח תחבירי של שורה), טבלת הסמלים, מפת
 הזיכרון, טבלאות קבועות (קודי הפעולה, שיטות המיעון החוקיות לכל פעולה, וכד').
 יש להקפיד ולתעד את המימוש באופן מלא וברור, באמצעות הערות מפורטות בקוד.

יש שי אופרדים המופרדים בפסיק, אזי לפי ואחרי הפסיק מותר שיהיו רווחים וטאבים  יש לאפשר תווים לבים עודפים בקובץ הקלט בשפת אסמבלי. למשל, אם בשורת הוראה
בכל כמות. בדומה, גם לפי ואחרי שם הפעולה. מותרות גם שורות ריקות. האסמבלר
 יתעלם מתווים לבים מיותרים (כלומר ידלג עליהם).
יש להדפיס למסך הודעות מפורטות ככל היתן, כדי שאפשר יהיה להבין מה והיכן כל שגיאה. השורות השגויות בקלט. אין לעצור את הטיפול בקובץ קלט לאחר גילוי השגיאה הראשוה.  הקלט (קוד האסמבלי) עלול להכיל שגיאות תחביריות. על האסמבלר לגלות ולדווח על כל
תם ושלם פרק ההסברים והגדרת הפרויקט. כמובן שאם קובץ קלט מכיל שגיאות, אין טעם להפיק עבורו את קבצי הפלט (ent ,ext ,ob(. */